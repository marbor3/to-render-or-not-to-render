{"componentChunkName":"component---gatsby-theme-mdx-deck-src-templates-deck-js","path":"//print","webpackCompilationHash":"26ee2f9a8d1b43b9aff6","result":{"data":{"deck":{"id":"1beb0f51-0e37-5aa0-827d-cff14ccdae7b","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar themes = [myTheme, nightOwl];\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  themes: themes,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(Split, {\n    mdxType: \"Split\"\n  }, mdx(\"h1\", null, \"To render or Not to render\"), mdx(\"img\", {\n    src: GrillJSLogo,\n    style: {\n      height: '20vh',\n      backgroundColor: '#ffffff',\n      padding: '2vh'\n    }\n  }), mdx(\"div\", null, \"2019\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Should I listen, or go grab a beer?\"), mdx(\"ul\", null, mdx(Appear, {\n    mdxType: \"Appear\"\n  }, mdx(\"li\", null, \"see some cool React stuff\"), mdx(\"li\", null, \"see some nice code\"), mdx(\"li\", null, \"with that gain new coding skills and impress your friends later \\uD83E\\uDDB8\\u200D\\u2642\\uFE0F, so ...\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, mdx(\"li\", null, \"see some cool React stuff\"), mdx(\"li\", null, \"see some nice code\"), mdx(\"li\", null, \"with that gain new coding skills and impress your friends later \\uD83E\\uDDB8\\u200D\\u2642\\uFE0F, so ...\"), \"Are you wondering if you should stay, or go grab something to eat, maybe a cold drink ... Sure, why not, but let me first tell you what you'll miss. You'll see some nice cool React stuff - only that should be enough to keep you sitting for the next 45 minutes! If that is not enough, you'll see some cool code on the screen.\"), mdx(\"hr\", null), mdx(\"img\", {\n    src: \"https://media.giphy.com/media/13cptIwW9bgzk6UVyr/giphy.gif\",\n    style: {\n      height: '80vh'\n    }\n  }), mdx(\"hr\", null), mdx(\"h2\", null, \"So how will I spend next 45 minutes?\"), mdx(\"ul\", null, mdx(Appear, {\n    mdxType: \"Appear\"\n  }, mdx(\"li\", null, \"Does render mean the same for everyone?\"), mdx(\"li\", null, \"How to get from user interaction to DOM render?\"), mdx(\"li\", null, \"Reconciliation, Fiber, Bail-out and more ...\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, mdx(\"li\", null, \"Does render mean the same for everyone?\"), mdx(\"li\", null, \"How to get from user interaction to DOM render?\"), mdx(\"li\", null, \"Reconciliation, Fiber, Bail-out and more ...\")), mdx(\"hr\", null), mdx(\"h2\", null, \"About me\"), mdx(\"ul\", null, mdx(Appear, {\n    mdxType: \"Appear\"\n  }, mdx(\"li\", null, \"Hi I\\u2019m Marcin, Frontend Engineer \\uD83D\\uDC4B\"), mdx(\"li\", null, \"I'm from Wroc\\u0142aw \\uD83D\\uDEF4\"), mdx(\"li\", null, \"I work as Frontend Engineer at Unic\"), mdx(\"li\", null, \"and I'm looking for new ways to improve my skills!\"), mdx(\"li\", null, \"you can find me on \", mdx(\"a\", {\n    href: \"https://github.com/marbor3/to-render-or-not-to-render\"\n  }, \"Github (/marbor3)\"), \" and \", mdx(\"a\", {\n    href: \"https://twitter.com/dobryglina\"\n  }, \"Twitter (@dobryglina)\"), \" where I have two friends (Hi Thomas, hi Wojtek) and two tweets \\uD83D\\uDCAA.\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, mdx(\"li\", null, \"Hi I\\u2019m Marcin, Frontend Engineer \\uD83D\\uDC4B\"), mdx(\"li\", null, \"I'm from Wroc\\u0142aw \\uD83D\\uDEF4\"), mdx(\"li\", null, \"I work as Frontend Engineer at Unic\"), mdx(\"li\", null, \"and I'm looking for new ways to improve my skills!\"), mdx(\"li\", null, \"you can find me on \", mdx(\"a\", {\n    href: \"https://github.com/marbor3/to-render-or-not-to-render\"\n  }, \"Github\"), \" and \", mdx(\"a\", {\n    href: \"https://twitter.com/dobryglina\"\n  }, \"Twitter\"), \" where I have two friends (Hi Thomas, hi Wojtek) and two tweets.\")), mdx(\"hr\", null), mdx(\"h1\", null, \"Why\"), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"I'm a Frontend Engineer, and I like it. I'm also getting paid for it! Which is even more awesome. But then I kinda feel that if someone pays me to get some work done, the outcome of my work should be at least good quality. What I'm trying to achive at my work is the feeling that with the current state of knowledge, both mine and stardards set by community I did what I could and I'm proud of it. For example someone joining to my project after it's developed for over year or two and saying, wow, this is one solid clean piece of application you guys build there! I strongly believe that understading mechanisms behind frameworks or libraries that we later use in our projects is the key to success.\"), mdx(\"hr\", null), mdx(\"h1\", null, \"What\"), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"Now that we know why I'm spending days and days on understanding library mechanisms it would be nice to know What exactly I wanted to show you today.\"), mdx(\"hr\", null), mdx(\"img\", {\n    src: ReactLogo,\n    style: {\n      height: '40vh',\n      padding: '2vh'\n    }\n  }), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"Let's start from the top. React. You've probably heard about that one. What it really does? If we look to React's home the vere first sentence says\"), mdx(\"hr\", null), mdx(\"img\", {\n    src: ReactHomePage,\n    style: {\n      height: '80vh',\n      padding: '2vh',\n      objectFit: 'contain'\n    }\n  }), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"React - A JavaScript library for building user interfaces. Now - it looks like React wont solve all our problems, but at least it should help with the UI.\"), mdx(\"hr\", null), mdx(CodeSurferLayout, {\n    mdxType: \"CodeSurferLayout\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const WishList = () => {\\n    return (\\n        <>\\n            All the wishes!\\n        </>\\n    );\\n};\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"2,6,7\",\n    \"2,6,7\": true\n  }), \"const WishList = () => {\\n    const [count, setCount] = useState(0);\\n\\n    return (\\n        <>\\n            <div>You have currently {count} wishes.</div>\\n            <button>Make a wish</button>\\n        </>\\n    );\\n};\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"3,4,5,9,10\",\n    \"3,4,5,9,10\": true\n  }), \"const WishList = () => {\\n    const [count, setCount] = useState(0);\\n    const makeAWish = function() {\\n        setCount(count => count + 1);\\n    };\\n\\n    return (\\n        <>\\n            <WishCounter count={count} />\\n            <button onClick={makeAWish}>Make a wish</button>\\n        </>\\n    );\\n};\\n\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"Let's imagine a small component - as WishList Is displays number of wishes we've made. Let's maybe add a possibility to wish for something. To make the wish come true we need to keep it to ourselfs, so we need only Make a wish button, not need to yell. Now clicking on Make a whish should increase our WishList counter. 'click' and it does So what does exactly React do for us here\"), mdx(\"hr\", null), mdx(Iframe, {\n    sandboxId: \"wishlist-0-0mmtp\",\n    mdxType: \"Iframe\"\n  }), mdx(\"hr\", null), mdx(\"h1\", null, \"Render?\"), mdx(\"img\", {\n    src: \"https://media.giphy.com/media/fV0oSDsZ4UgdW/giphy.gif\",\n    style: {\n      width: '80vh',\n      padding: '2vh'\n    }\n  }), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"There are two meanings of \\u201Crender\\u201D in React that people often get confused about: (1) getting the React elements from your components (calling your component\\u2019s render method) during an update and (2) actually rendering updates to the DOM From now on lets stick to the first definition, so for us 'reder' is: The phase in when React determines what changes need to be made to e.g. the DOM. During this phase, React calls render and then compares the result to the previous render. and the second one we'll call commit: The phase is when React applies any changes. (In the case of React DOM, this is when React inserts, updates, and removes DOM nodes.) Let's focus first on render phase. So we know React must be keeping somehow representation of our components, to then compare it and apply updates to the DOM. But how this exactly looks like?\"), mdx(\"hr\", null), mdx(\"h1\", null, \"VirtualDOM\"), mdx(\"ul\", null, mdx(Appear, {\n    mdxType: \"Appear\"\n  }, mdx(\"li\", null, \"a concept where 'virtual' representation of UI is kept in memory\"), mdx(\"li\", null, \"it's idea is to abstract any manipulations of DOM, and with that abstraction optimise them\"), mdx(\"li\", null, \"the virtual abstraction is synced with browser or possibly other outputs using libraries like ReactDOM, React Native, React VR?\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, mdx(\"li\", null, \"a concept where 'virtual' representation of UI is kept in memory\"), mdx(\"li\", null, \"it's idea is to abstract any manipulations of DOM, and with that abstraction optimise them\"), mdx(\"li\", null, \"the virtual abstraction is synced with browser or possibly other outputs using libraries like ReactDOM, React Navite, React VR?\"), \"When React came out VirtualDOM was a huge thing, simple yet atractive. Lately, community figured out that React could be bound to different types of outputs, not only DOM, also Native Phone apps, PDFs Virtual Reality? That's why last few years guys in core React team were rewritting it's core algorithm in a completely new way.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Fiber reconciliation algorithm\"), mdx(\"img\", {\n    src: \"https://media.giphy.com/media/iMJSCqtsi20V9xgpPu/giphy.gif\",\n    style: {\n      width: '60vh'\n    }\n  }), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"Yep, that's the thing. You may have heard about it, it's been around almost two years now. This is one of the key parts of React Core. So lets start from the basics, what is reconciliation?\"), mdx(\"hr\", null), mdx(\"h1\", null, \"Reconciliation\"), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"In a nutshell, Reconciliation is a Diffing algorithm that calculates what changes need to be done from current state of our Application Components after changing it's state in some way. It's independet on DOM updates, that was one of they focus points React Core Team tried to accomplish. We can later have multiple different 'rendering engines' like react-dom or react native to figure out real changes that output components that needs to be done. Another focus point was - to make this phase interuptable, to be able to priotiaze some work, or even add more threads to deal with some work, possibly in shorter amount of time. In order to understand basics of this algorithm we need to understand how does representation of our comonents look inside React. Let's check out Fibers.\"), mdx(\"hr\", null), mdx(CodeSurferLayout, {\n    mdxType: \"CodeSurferLayout\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const WishList = () => {\\n    const [count, setCount] = useState(0);\\n    const makeAWish = function() {\\n        setCount(count => count + 1);\\n    };\\n\\n    return [\\n        <WishCounter key=\\\"counter\\\" count={count} />,\\n        <button key=\\\"make-a-wish\\\" onClick={makeAWish}>\\n            Make a wish\\n        </button>\\n    ];\\n};\\n\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"Let's got back to our Wishlist example. As you may remember this was a simple contaner with single state, text to display state value and a button to inrease state value. But this is a functional component with JSX, in order to process it further, React transforms JSX to set of element contructors.\"), mdx(\"hr\", null), mdx(CodeSurferLayout, {\n    mdxType: \"CodeSurferLayout\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const WishList = () => {\\n    const [count, setCount] = useState(0);\\n    const makeAWish = function() {\\n        setCount(count => count + 1);\\n    };\\n\\n    return [\\n        React.createElement(WishCounter, {\\n            key: \\\"counter\\\",\\n            count: count\\n        }),\\n        React.createElement(\\n            \\\"button\\\",\\n            {\\n                key: \\\"make-a-wish\\\",\\n                onClick: makeAWish\\n            },\\n            \\\"Make a wish\\\"\\n        )\\n    ];\\n};\\n\\n\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"We might even try to write code like this. The construction is simple and understandable. With this React can then run the 'render' method to create React elements.\"), mdx(\"hr\", null), mdx(CodeSurferLayout, {\n    mdxType: \"CodeSurferLayout\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"{\\n    $$typeof: Symbol(react.element)\\n    props: {\\n        children: [\\n            {\\n                $$typeof: Symbol(react.element)\\n                props: {count: 3}\\n                type: \\u0192 WishCounter(_ref)\\n            }, {\\n                $$typeof: Symbol(react.element)\\n                props: {onClick: \\u0192, children: \\\"Add a wish\\\"}\\n                type: \\\"button\\\"\\n            }\\n        ]\\n    },\\n    type: Symbol(react.fragment)\\n}\\n\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"With some simplification it's roughly how a sample 'render' output of our example looks. While this is getting more complicated, this is still a plain old tree, one can easily imagine it's DOM representation.\"), mdx(\"hr\", null), mdx(\"h1\", null, \"Fiber\"), mdx(\"img\", {\n    src: \"https://media.giphy.com/media/3oKIPpFhwsMNrRIjN6/giphy.gif\",\n    style: {\n      width: '80vh'\n    }\n  }), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"Then our reconciliation algorithm steps in, data from every React element returned from the render method is merged into the tree of fiber nodes. Every React element has a corresponding fiber node. Unlike React elements, like the ones here, fibers aren\\u2019t re-created on every render. They rather represent a Unit of Work. To cover the whole topic, we would need rest of the day, so let me show you a bit simplified version, to get the core idea of the algorithm. Main reasons behind rewriting this part of React were:\", mdx(\"li\", null, \"to be able to pause work and come back to it later\"), mdx(\"li\", null, \"assign priority to different types of work.\"), mdx(\"li\", null, \"reuse previously completed work.\"), mdx(\"li\", null, \"abort work if it's no longer needed.\"), \"and with that first we could probably observe performance boost at least in some situations. And second - it could then serve as base for next planned updates - error boundaries and suspense. Now lets check out structure of a Fiber\"), mdx(\"hr\", null), mdx(CodeSurferLayout, {\n    mdxType: \"CodeSurferLayout\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"{\\n    alternate: FiberNode {}\\n    child: FiberNode {\\n        tag: 5,\\n        elementType: \\\"div\\\",\\n        type: \\\"div\\\",\\n        stateNode: div,\\n        \\u2026\\n    }\\n    elementType: \\u0192 WishCounter(_ref)\\n    firstEffect: null\\n    lastEffect: FiberNode {}\\n    memoizedProps: {count: 2}\\n    memoizedState: null\\n    nextEffect: null\\n    pendingProps: {count: 2}\\n    return: FiberNode {}\\n    sibling: FiberNode {\\n        tag: 5,\\n        elementType: \\\"button\\\",\\n        type: \\\"button\\\",\\n        stateNode: button,\\n        \\u2026\\n    }\\n    stateNode: null\\n    tag: 0\\n    type: \\u0192 WishCounter(_ref)\\n    updateQueue: null\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"3,17,18\",\n    \"3,17,18\": true\n  }), \"{\\n    alternate: FiberNode {}\\n    child: FiberNode {\\n        tag: 5,\\n        elementType: \\\"div\\\",\\n        type: \\\"div\\\",\\n        stateNode: div,\\n        \\u2026\\n    }\\n    elementType: \\u0192 WishCounter(_ref)\\n    firstEffect: null\\n    lastEffect: FiberNode {}\\n    memoizedProps: {count: 2}\\n    memoizedState: null\\n    nextEffect: null\\n    pendingProps: {count: 2}\\n    return: FiberNode {}\\n    sibling: FiberNode {\\n        tag: 5,\\n        elementType: \\\"button\\\",\\n        type: \\\"button\\\",\\n        stateNode: button,\\n        \\u2026\\n    }\\n    stateNode: null\\n    tag: 0\\n    type: \\u0192 WishCounter(_ref)\\n    updateQueue: null\\n}\\n\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"Like React element, this example shows also simplified Fiber Node. For now lets focus on this 3 elements - child, sibling, return. What could look like a tree at first galance in fact is a bit more tricky structure.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Singly linked list tree traversal\"), mdx(\"img\", {\n    src: Fiber,\n    style: {\n      width: '80vh',\n      backgroundColor: '#ffffff',\n      padding: '2vh'\n    }\n  }), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"Looking at our WishList example - this shows how Fibers are linked within the component. Interesting is fact that there's no connection from parent to all children, only first child. Then each child Fiber is connected with it's siblings. Now lets make things complicated. Short intro into how things work. Work starts from the top. Then the order of work looks similar to what we know from source debugging. React steps into child Fiber, begins work there, and does that for until there's no child for a Fiber or for some reason (on that later) there's no work to be done there. Then it checks for existing sibling Fiber and so on. During work render methods from our components are run, this may lead to list of changes that need to be done later. Important to remember - this phase does not produce any changes to the DOM, it can be done asynchronus. As a result we have a list of 'effects' that the followup phase will process and in that phase - commit, we'll see our DOM updated. Thing about async nature of this algorithm - the idea is that this phase is run whenever there's a browser idle period, for that is uses `requestIdleCallback` and polyfills it when needed. So whenever's theres still time, it processes the list. When there's high priority task - like animation - comming, the work can be paused and continied later. To keep the page at 60fps, it means it will have each time 16ms before next animation frame.\"), mdx(\"hr\", null), mdx(CodeSurferLayout, {\n    mdxType: \"CodeSurferLayout\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"3,17,18\",\n    \"3,17,18\": true\n  }), \"{\\n    alternate: FiberNode {}\\n    child: FiberNode {\\n        tag: 5,\\n        elementType: \\\"div\\\",\\n        type: \\\"div\\\",\\n        stateNode: div,\\n        \\u2026\\n    }\\n    elementType: \\u0192 WishCounter(_ref)\\n    firstEffect: null\\n    lastEffect: FiberNode {}\\n    memoizedProps: {count: 2}\\n    memoizedState: null\\n    nextEffect: null\\n    pendingProps: {count: 2}\\n    return: FiberNode {}\\n    sibling: FiberNode {\\n        tag: 5,\\n        elementType: \\\"button\\\",\\n        type: \\\"button\\\",\\n        stateNode: button,\\n        \\u2026\\n    }\\n    stateNode: null\\n    tag: 0\\n    type: \\u0192 WishCounter(_ref)\\n    updateQueue: null\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"11,12,15\",\n    \"11,12,15\": true\n  }), \"{\\n    alternate: FiberNode {}\\n    child: FiberNode {\\n        tag: 5,\\n        elementType: \\\"div\\\",\\n        type: \\\"div\\\",\\n        stateNode: div,\\n        \\u2026\\n    }\\n    elementType: \\u0192 WishCounter(_ref)\\n    firstEffect: null\\n    lastEffect: FiberNode {}\\n    memoizedProps: {count: 2}\\n    memoizedState: null\\n    nextEffect: null\\n    pendingProps: {count: 2}\\n    return: FiberNode {}\\n    sibling: FiberNode {\\n        tag: 5,\\n        elementType: \\\"button\\\",\\n        type: \\\"button\\\",\\n        stateNode: button,\\n        \\u2026\\n    }\\n    stateNode: null\\n    tag: 0\\n    type: \\u0192 WishCounter(_ref)\\n    updateQueue: null\\n}\\n\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"fibers also play role in effect list, this is a linked list, with pointers to first, next and last effect in current subtree. With the introduction of hooks and new algorithm we need to switch a bit our mindsets to think in effects rather in lifecycle callbacks. But more on that later\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Commit phase\"), mdx(\"img\", {\n    src: \"https://media.giphy.com/media/d31vTpVi1LAcDvdm/giphy.gif\",\n    style: {\n      width: '80vh'\n    }\n  }), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"Previously we've learned that out of render phase we're getting a list of effects. This is a singly linked list in which order of the effects is set not only on the fact when the Fiber was processed by reconciliation, but also by priority of the effect. For example animation effects have a higher prority then data fetching and will be resolved earlier. Important here is - the whole phase is synchronus - so all changes will be commited without breaks. Taking a look how it used to work in versions before 16 - after each component render menthod being called, all DOM updates were imediatelly run afterwards and like this component after component. It's a huge step forward! Now lets move to the next point - a very important place where we can make things run faster or more often - make things go slower is the render function of our component.\"), mdx(\"hr\", null), mdx(\"h1\", null, \"Avoiding re-renders\"), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"On one side, with the optimizations to reconciliation and spliting commit phase the topic is not that important in our daily life. Also following rule not to optimize your code premature and withour proper measurments - we don't really need to do anything at the beginning. But to be able to solve probles as they start to appear, or just if we enojoy even microptimizaitons we should know our possibilities or even where to start.\"), mdx(\"hr\", null), mdx(\"h1\", null, \"React.memo and React.PureComponent\"), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"There's a way to tell component that nothing changed inside, even if it get's new props. This can be done with React.memo for functional components. Lets extend our Wishlist example with and input field, where we write our wish, and some text field that displays the text you entered as soon as you hit a key.\"), mdx(\"hr\", null), mdx(CodeSurferLayout, {\n    mdxType: \"CodeSurferLayout\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const WishList = () => {\\n    const [count, setCount] = useState(0);\\n    const makeAWish = function() {\\n        setCount(count => count + 1);\\n    };\\n\\n    return [\\n        <WishCounter key=\\\"counter\\\" count={count} />,\\n        <button key=\\\"make-a-wish\\\" onClick={makeAWish}>\\n            Make a wish\\n        </button>\\n    ];\\n};\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"3,6,10,12,13,14,15,19,20,21,22,23,24\",\n    \"3,6,10,12,13,14,15,19,20,21,22,23,24\": true\n  }), \"const WishList = () => {\\n    const [count, setCount] = useState(0);\\n    const [wishInProgress, setWishInProgress] = useState(\\\"\\\");\\n    const makeAWish = function() {\\n        setCount(count => count + 1);\\n        setWishInProgress(\\\"\\\");\\n    };\\n\\n    return (\\n        <Profiler id=\\\"wishlist\\\">\\n            <WishCounter key=\\\"counter\\\" count={count} />\\n            <WishText\\n                key=\\\"wish-text\\\"\\n                setWishInProgress={setWishInProgress}\\n            />\\n            <button key=\\\"make-a-wish\\\" onClick={makeAWish}>\\n                Make a wish\\n            </button>\\n            <WishPreview\\n                key=\\\"wish-in-progress\\\"\\n                wishInProgress={wishInProgress}\\n            />\\n        </Profiler>\\n    );\\n};\\n\"))), mdx(\"hr\", null), mdx(CodeSurferLayout, {\n    mdxType: \"CodeSurferLayout\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const onRender = (\\n    profilerId, // the \\\"id\\\" prop of the Profiler tree that has just committed\\n    phase, // either \\\"mount\\\" (if the tree just mounted) or \\\"update\\\" (if it re-rendered)\\n    actualDuration, // time spent rendering the committed update\\n    baseDuration, // estimated time to render the entire subtree without memoization\\n    startTime, // when React began rendering this update\\n    commitTime, // when React committed this update\\n    interactions // the Set of interactions belonging to this update\\n) => {\\n    console.log(\\n        `%c${phase}%c %c${profilerId}%c %c${Math.round(actualDuration * 100) /\\n            100}ms`,\\n        \\\"color: white; background-color: #FF1654; padding: 2px 5px; border-radius: 2px; margin: 0;\\\",\\n        {},\\n        \\\"color: white; background-color: #247BA0; padding: 2px 5px; border-radius: 2px\\\",\\n        {},\\n        \\\"color: white; background-color: #70C1B3; padding: 2px 5px; border-radius: 2px\\\",\\n        interactions\\n    );\\n};\\n\\nconst Profiler = ({ id, children }) => (\\n    <React.Profiler id={id} onRender={onRender}>\\n        {children}\\n    </React.Profiler>\\n);\\n\"))), mdx(\"hr\", null), mdx(CodeSurferLayout, {\n    mdxType: \"CodeSurferLayout\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const WishText = ({ setWishInProgress }) => (\\n    <Profiler id=\\\"wish-text\\\">\\n        <input\\n            onChange={event => {\\n                setWishInProgress(event.currentTarget.value);\\n            }}\\n            type=\\\"text\\\"\\n        />\\n    </Profiler>\\n);\\n\"))), mdx(\"hr\", null), mdx(CodeSurferLayout, {\n    mdxType: \"CodeSurferLayout\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const WishPreview = ({ wishInProgress }) => (\\n    <Profiler id=\\\"wish-preview\\\">\\n        {wishInProgress !== \\\"\\\" ? (\\n            <div>\\n                What I would really like from Santa is ... {wishInProgress}\\n            </div>\\n        ) : null}\\n    </Profiler>\\n);\\n\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"By default whenever a state changes on the top level, all child components are re-rendered (remember, that does not mean any DOM will change, just that their render function will run again). We can easily avoid it in cases that for some children there's no change in properties that they use. It's called memoization, can be done with: wrapping your functional component in `React.memo` call or extending React.PureComponent class in class components.\"), mdx(\"hr\", null), mdx(Iframe, {\n    sandboxId: \"wishlist-1-8vrrm\",\n    mdxType: \"Iframe\"\n  }), mdx(\"hr\", null), mdx(CodeSurferLayout, {\n    mdxType: \"CodeSurferLayout\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const WishCounter = ({ count }) => (\\n    <Profiler id=\\\"wish-counter\\\">\\n        <div>You have currently {count} wishes:</div>\\n    </Profiler>\\n);\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"1,2,3,5,9\",\n    \"1,2,3,5,9\": true\n  }), \"function areEqual(prevProps, nextProps) {\\n    return prevProps.count === nextProps.count;\\n}\\n\\nconst WishCounter = React.memo(({ count }) => (\\n    <Profiler id=\\\"wish-counter\\\">\\n        <div>You have currently {count} wishes:</div>\\n    </Profiler>\\n), areEqual);\\n\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"In our example, whenever something is writen inside input field all components on the page are re-rendered. This does not cost a lot, untill it does ... React.memo uses a shallow comparison to compare old and new props, if those match, there's no re-render. To add more sophisticated logic to comparison function there's a second argument for React.memo, a function to compare if components are equal considering prev and next props. Important - this is the opposite to shouldComponentUpdate function.\"), mdx(\"hr\", null), mdx(Iframe, {\n    sandboxId: \"wishlist-1-g4zhw\",\n    mdxType: \"Iframe\"\n  }), mdx(\"hr\", null), mdx(\"h1\", null, \"React.memo all the things!\"), mdx(\"img\", {\n    src: \"https://media.giphy.com/media/l3q2t2KAyvxy9xBe0/giphy.gif\",\n    style: {\n      width: '60vw'\n    }\n  }), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"It coudln't be that easy, could it? There's at least one case it wont make sense and in fact will hurt performance. React.memo adds additional check before rendering, if our component properties change a lot, we will be doing uneeded check in all these cases. Besides, it's exteamly important to remember - premature optimization is always a bad thing. Measure then make improvements and measure again. What I show you here are techniques to tryout where you already have a problem with performance.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"useMemo\"), mdx(CodeSurferLayout, {\n    mdxType: \"CodeSurferLayout\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"2,9\",\n    \"2,9\": true\n  }), \"const WishList = () => {\\n    const startsCount = useMemo(() => countStars(count), [count]);\\n\\n    return (\\n        <Profiler id=\\\"wishlist\\\">\\n            <WishCounter key=\\\"counter\\\" count={count} />\\n            <WishText key=\\\"wish-text\\\" setWishInProgress={setWishInProgress} />\\n            <button key=\\\"make-a-wish\\\" onClick={makeAWish}>\\n                `Make a wish, there are still {startsCount} stars`\\n            </button>\\n        </Profiler>\\n    );\\n};\\n\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"For functional components rendering causes any calculations you have inside the component to be recomputed. In some cases we need to make some complex and heavy operations in one of our components. We want to not only count on Bail-out, we can save some computation time and therefore speed our app by wraping heavy computation functions in useMemo hook. as a second argument we provide an array of properties to be watched for changes, if any of those change, function will be run.\"), mdx(\"hr\", null), mdx(Iframe, {\n    sandboxId: \"wishlist-2-z3cmp\",\n    mdxType: \"Iframe\"\n  }), mdx(\"hr\", null), mdx(\"img\", {\n    src: noUseMemo\n  }), mdx(\"hr\", null), mdx(Iframe, {\n    sandboxId: \"wishlist-22-fztmd\",\n    mdxType: \"Iframe\"\n  }), mdx(\"hr\", null), mdx(\"h2\", null, \"useCallback\"), mdx(CodeSurferLayout, {\n    mdxType: \"CodeSurferLayout\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const WishList = () => {\\n    const makeAWish = useCallback(\\n        function() {\\n            if (count < 3) {\\n                setCount(count => count + 1);\\n                setWishInProgress(\\\"\\\");\\n            }\\n        },\\n        [count]\\n    );\\n\\n    return (\\n        <Profiler id=\\\"wishlist\\\">\\n            <MakeAWish makeAWish={makeAWish} />\\n        </Profiler>\\n    );\\n};\\n\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"useCallback, another way to bail out of rendering, this time for functions. Passes memoized version of callback that only changes when one of dependencies in array changes.\"), mdx(\"hr\", null), mdx(Iframe, {\n    sandboxId: \"wishlist-3-yis9c\",\n    mdxType: \"Iframe\"\n  }), mdx(\"hr\", null), mdx(Iframe, {\n    sandboxId: \"wishlist-3-5xev3\",\n    mdxType: \"Iframe\"\n  }), mdx(\"hr\", null), mdx(\"h1\", null, \"useRef\"), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"TODO: some useRef example Worth mentioning is also useRef - most common use case of refs was to get access to DOM nodes or React elements, but in general current property of ref can hold any value, is mutable and chaning it doesn't trigger a re-render.\"), mdx(\"hr\", null), mdx(\"h1\", null, \"Object literals in JSX\"), mdx(\"hr\", null), mdx(CodeSurferLayout, {\n    mdxType: \"CodeSurferLayout\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"7\": true,\n    \"className\": \"language-js\",\n    \"metastring\": \"7\"\n  }), \"const WishList = () => {\\n    const [wishInProgress, setWishInProgress] = useState(\\\"\\\");\\n\\n    return (\\n        <Profiler id=\\\"wishlist\\\">\\n            <WishText\\n                style={{ marginTop: 10 }}\\n                setWishInProgress={setWishInProgress}\\n            />\\n        </Profiler>\\n    );\\n};\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"1,9\",\n    \"1,9\": true\n  }), \"const style = { marginTop: 10 };\\n\\nconst WishList = () => {\\n    const [wishInProgress, setWishInProgress] = useState(\\\"\\\");\\n\\n    return (\\n        <Profiler id=\\\"wishlist\\\">\\n            <WishText\\n                style={style}\\n                setWishInProgress={setWishInProgress}\\n            />\\n        </Profiler>\\n    );\\n};\\n\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, \"Beware of object literals in JSX, each re-render creates a new object that then is passed to child coponent. React.memo uses shallow comparison by default so this will cause our child component to re-render every time parent re-renders.\"), mdx(\"hr\", null), mdx(Iframe, {\n    sandboxId: \"wishlist-31-emy6y\",\n    mdxType: \"Iframe\"\n  }), mdx(\"hr\", null), mdx(Iframe, {\n    sandboxId: \"wishlist-4-clkqo\",\n    mdxType: \"Iframe\"\n  }), mdx(\"hr\", null), mdx(\"h2\", null, \"Re-write all the code!\"), mdx(Appear, {\n    mdxType: \"Appear\"\n  }, mdx(\"h3\", null, \"Measure before you optimise!\")), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, mdx(\"h3\", null, \"Measure before you optimize!\"), \"If you aren\\u2019t measuring, you can\\u2019t even know if your optimisations are better, and you certainly won\\u2019t know if they make things worse!\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Some tools to help you optimize your app\"), mdx(\"ul\", null, mdx(Appear, {\n    mdxType: \"Appear\"\n  }, mdx(\"li\", null, mdx(\"a\", {\n    href: \"https://react-devtools-tutorial.now.sh/\"\n  }, \"React dev tools tutorial\")), mdx(\"li\", null, mdx(\"a\", {\n    href: \"https://calibreapp.com/blog/react-performance-profiling-optimization/\"\n  }, \"Chrome dev tools - profiling React performance\")), mdx(\"li\", null, mdx(\"a\", {\n    href: \"https://github.com/welldone-software/why-did-you-render\"\n  }, \"why did you render\")), mdx(\"li\", null, mdx(\"a\", {\n    href: \"https://github.com/maicki/why-did-you-update\"\n  }, \"why did you update\")))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, mdx(\"li\", null, mdx(\"a\", {\n    href: \"https://react-devtools-tutorial.now.sh/\"\n  }, \"React dev tools tutorial\")), mdx(\"li\", null, mdx(\"a\", {\n    href: \"https://calibreapp.com/blog/react-performance-profiling-optimization/\"\n  }, \"Chrome dev tools - profiling React performance\")), mdx(\"li\", null, mdx(\"a\", {\n    href: \"https://github.com/welldone-software/why-did-you-render\"\n  }, \"why did you render\")), mdx(\"li\", null, mdx(\"a\", {\n    href: \"https://github.com/maicki/why-did-you-update\"\n  }, \"why did you update\"))), mdx(\"hr\", null), mdx(\"h1\", null, \"Summary\"), mdx(\"ul\", null, mdx(Appear, {\n    mdxType: \"Appear\"\n  }, mdx(\"li\", null, \"Know your tools - just reading React docs and understanding it will boost your code five times.\"), mdx(\"li\", null, \"Try out things when learning - codesandbox.io \\u2764 \"), mdx(\"li\", null, \"Be cautious with premature optimizations.\"))), mdx(Notes, {\n    mdxType: \"Notes\"\n  }, mdx(\"li\", null, \"Know your tools - just reading React docs and understanding it will boost your code five times.\"), mdx(\"li\", null, \"Try out things when learning - codesandbox.io \\u2764 \"), mdx(\"li\", null, \"Be cautious with premature optimisations.\")), mdx(\"hr\", null), mdx(\"h1\", null, \"This wouldn't be possible if not for awesome community\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://medium.com/react-in-depth\"\n  }), \"React in Depth\"), \" by Max Koretskyi aka Wizard\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://hackernoon.com/react-performance-primer-64fe623c4821\"\n  }), \"React Performance Primer\"), \" by Carlos Matias\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://itnext.io/6-tips-for-better-react-performance-4329d12c126b\"\n  }), \"6 tips for better React performance\"), \" by Aggelos Arvanitakis\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://reactjs.org/docs/reconciliation.html\"\n  }), \"React docs\"), \" by \\uD83E\\uDDB8\\u200D\\u2642\\uFE0F\")), mdx(\"hr\", null), mdx(\"p\", null, \"Thank you for listening \\uD83C\\uDF7B!\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"1beb0f51-0e37-5aa0-827d-cff14ccdae7b","slug":"","title":"To render or Not to render"}}}